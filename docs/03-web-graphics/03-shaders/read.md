---
sidebar_position: 1
---

# Read

> written by [Martijn Benjamin](https://www.linkedin.com/in/martijn-benjamin/) ([appeltje-c](https://github.com/appeltje-c))



**Vertex and fragment shaders** are part of the **graphics pipeline** used in **GPU programming** (particularly in OpenGL, DirectX, and Vulkan) to render 3D scenes on a screen. These shaders are small programs that run on the GPU to handle specific stages of rendering, transforming 3D models into pixels on a 2D screen. Here's a breakdown of how they work:

---

### **1. Vertex Shader**

The **vertex shader** processes each **vertex** in a 3D model. A vertex is a point in 3D space with attributes such as position, color, and texture coordinates.

#### **What the Vertex Shader Does:**
- **Transforms vertices**: Takes vertex data (usually in 3D space) and transforms it into a different coordinate system (like 2D screen coordinates) using **transformation matrices** (like the model-view-projection matrix).
- **Lighting calculations**: Basic lighting computations can be done at the vertex level, such as calculating light direction, diffuse/specular components, etc.
- **Outputs data for further stages**: It outputs the transformed vertex position and other attributes (color, texture coordinates, normals, etc.) to the next stage in the pipeline.

#### Example Workflow:
1. A vertex is defined with attributes such as position, normal, color, and texture coordinates.
2. The vertex shader applies transformations (e.g., rotation, scaling, and projection).
3. The vertex shader outputs the final **position** of the vertex in clip space, along with other attributes like interpolated color and texture coordinates.

#### Example GLSL Vertex Shader:
```glsl
#version 330 core
layout(location = 0) in vec3 aPos; // Vertex position
layout(location = 1) in vec3 aColor; // Vertex color

out vec3 vColor; // Output to the next stage (fragment shader)

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    // Transform the vertex position
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    // Pass the color to the next stage
    vColor = aColor;
}
```

- **Input**: Vertex data (position, color, etc.).
- **Output**: Transformed vertex position and interpolated attributes like color and texture coordinates.

### **2. Fragment Shader**

The **fragment shader** (also called a pixel shader) operates on **fragments** (essentially potential pixels), determining the final color of each pixel in the 2D image being rendered.

#### **What the Fragment Shader Does:**
- **Coloring and Texturing**: It computes the color of a pixel based on inputs from the vertex shader, like interpolated color, lighting, and texture data.
- **Lighting**: Per-pixel lighting can be calculated for more accurate and realistic rendering (e.g., diffuse and specular lighting).
- **Outputs pixel color**: The fragment shader outputs the final color that will be drawn on the screen at a specific pixel location.

#### Example Workflow:
1. Interpolated data from the vertex shader (like position, color, and texture coordinates) is passed to the fragment shader for each pixel.
2. The fragment shader calculates the color of the pixel using various techniques, including texturing, lighting, or procedural shading.
3. The fragment shader outputs the final color for each pixel on the screen.

#### Example GLSL Fragment Shader:
```glsl
#version 330 core
in vec3 vColor; // Input from vertex shader

out vec4 FragColor; // Output final color

void main()
{
    // Set the fragment's color
    FragColor = vec4(vColor, 1.0); // Set final pixel color
}
```

- **Input**: Data like interpolated color and texture coordinates from the vertex shader.
- **Output**: Final color of each pixel.

---

### **How Vertex and Fragment Shaders Work Together**

1. **Model Definition**: A 3D model is defined with a set of vertices (points in space).
2. **Vertex Shader Stage**: 
   - The vertex shader runs once for each vertex.
   - It processes the vertexâ€™s position and applies transformations, such as model, view, and projection transformations.
   - It sends transformed vertex positions and other attributes (like color or texture coordinates) to the **rasterizer** stage.
   
3. **Rasterization**:
   - The rasterizer converts the transformed 3D triangles into a set of 2D fragments (potential pixels) on the screen.
   - It interpolates the attributes passed from the vertex shader (e.g., color and texture coordinates) across each triangle.

4. **Fragment Shader Stage**:
   - The fragment shader runs for each fragment generated by the rasterizer.
   - It computes the final color of the pixel, possibly using interpolated data (like color, lighting, or texture data).
   - This color is then written to the framebuffer (the final image).

### **Visual Representation**:

- **Vertex Shader**: Handles **per-vertex** calculations like position and basic lighting.
- **Rasterizer**: Converts the triangle formed by the vertices into pixels.
- **Fragment Shader**: Handles **per-pixel** calculations like coloring and detailed lighting.

---

### **Key Differences:**

| **Vertex Shader**                              | **Fragment Shader**                           |
|-----------------------------------------------|-----------------------------------------------|
| Processes **vertices** (points in 3D space).  | Processes **fragments** (potential pixels).   |
| Handles transformations, like position and lighting. | Handles coloring, texturing, and pixel-specific effects. |
| Runs **once per vertex**.                      | Runs **once per pixel/fragment**.             |
| Outputs vertex position and attributes.        | Outputs final pixel color.                    |

### **Example Use Cases**:
- **Vertex Shader**: Used to transform a 3D model's vertices into screen space for rendering.
- **Fragment Shader**: Used to apply lighting, shading, and texturing to determine the color of each pixel.

---

### Summary:
- **Vertex Shaders**: Focus on manipulating vertex positions and attributes.
- **Fragment Shaders**: Focus on determining the final pixel color by applying textures, lighting, or shading techniques.
  
These shaders work in tandem to render 3D scenes efficiently on the GPU.