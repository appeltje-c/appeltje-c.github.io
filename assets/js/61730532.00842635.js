"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2671],{4666:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var t=r(5893),s=r(1151);const i={sidebar_position:1},l="Read",o={id:"web-graphics/shaders/read",title:"Read",description:"written by Martijn Benjamin (appeltje-c)",source:"@site/docs/03-web-graphics/03-shaders/read.md",sourceDirName:"03-web-graphics/03-shaders",slug:"/web-graphics/shaders/read",permalink:"/web-graphics/shaders/read",draft:!1,unlisted:!1,editUrl:"https://github.com/appeltje-c/appeltje-c.github.io/tree/main/docs/03-web-graphics/03-shaders/read.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Shaders",permalink:"/category/shaders"},next:{title:"Connectivity",permalink:"/category/connectivity"}},a={},d=[{value:"<strong>1. Vertex Shader</strong>",id:"1-vertex-shader",level:3},{value:"<strong>What the Vertex Shader Does:</strong>",id:"what-the-vertex-shader-does",level:4},{value:"Example Workflow:",id:"example-workflow",level:4},{value:"Example GLSL Vertex Shader:",id:"example-glsl-vertex-shader",level:4},{value:"<strong>2. Fragment Shader</strong>",id:"2-fragment-shader",level:3},{value:"<strong>What the Fragment Shader Does:</strong>",id:"what-the-fragment-shader-does",level:4},{value:"Example Workflow:",id:"example-workflow-1",level:4},{value:"Example GLSL Fragment Shader:",id:"example-glsl-fragment-shader",level:4},{value:"<strong>How Vertex and Fragment Shaders Work Together</strong>",id:"how-vertex-and-fragment-shaders-work-together",level:3},{value:"<strong>Visual Representation</strong>:",id:"visual-representation",level:3},{value:"<strong>Key Differences:</strong>",id:"key-differences",level:3},{value:"<strong>Example Use Cases</strong>:",id:"example-use-cases",level:3},{value:"Summary:",id:"summary",level:3}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"read",children:"Read"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["written by ",(0,t.jsx)(n.a,{href:"https://www.linkedin.com/in/martijn-benjamin/",children:"Martijn Benjamin"})," (",(0,t.jsx)(n.a,{href:"https://github.com/appeltje-c",children:"appeltje-c"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Vertex and fragment shaders"})," are part of the ",(0,t.jsx)(n.strong,{children:"graphics pipeline"})," used in ",(0,t.jsx)(n.strong,{children:"GPU programming"})," (particularly in OpenGL, DirectX, and Vulkan) to render 3D scenes on a screen. These shaders are small programs that run on the GPU to handle specific stages of rendering, transforming 3D models into pixels on a 2D screen. Here's a breakdown of how they work:"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"1-vertex-shader",children:(0,t.jsx)(n.strong,{children:"1. Vertex Shader"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"vertex shader"})," processes each ",(0,t.jsx)(n.strong,{children:"vertex"})," in a 3D model. A vertex is a point in 3D space with attributes such as position, color, and texture coordinates."]}),"\n",(0,t.jsx)(n.h4,{id:"what-the-vertex-shader-does",children:(0,t.jsx)(n.strong,{children:"What the Vertex Shader Does:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transforms vertices"}),": Takes vertex data (usually in 3D space) and transforms it into a different coordinate system (like 2D screen coordinates) using ",(0,t.jsx)(n.strong,{children:"transformation matrices"})," (like the model-view-projection matrix)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lighting calculations"}),": Basic lighting computations can be done at the vertex level, such as calculating light direction, diffuse/specular components, etc."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Outputs data for further stages"}),": It outputs the transformed vertex position and other attributes (color, texture coordinates, normals, etc.) to the next stage in the pipeline."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-workflow",children:"Example Workflow:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"A vertex is defined with attributes such as position, normal, color, and texture coordinates."}),"\n",(0,t.jsx)(n.li,{children:"The vertex shader applies transformations (e.g., rotation, scaling, and projection)."}),"\n",(0,t.jsxs)(n.li,{children:["The vertex shader outputs the final ",(0,t.jsx)(n.strong,{children:"position"})," of the vertex in clip space, along with other attributes like interpolated color and texture coordinates."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-glsl-vertex-shader",children:"Example GLSL Vertex Shader:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-glsl",children:"#version 330 core\nlayout(location = 0) in vec3 aPos; // Vertex position\nlayout(location = 1) in vec3 aColor; // Vertex color\n\nout vec3 vColor; // Output to the next stage (fragment shader)\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nvoid main()\n{\n    // Transform the vertex position\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\n    // Pass the color to the next stage\n    vColor = aColor;\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Input"}),": Vertex data (position, color, etc.)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Output"}),": Transformed vertex position and interpolated attributes like color and texture coordinates."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-fragment-shader",children:(0,t.jsx)(n.strong,{children:"2. Fragment Shader"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"fragment shader"})," (also called a pixel shader) operates on ",(0,t.jsx)(n.strong,{children:"fragments"})," (essentially potential pixels), determining the final color of each pixel in the 2D image being rendered."]}),"\n",(0,t.jsx)(n.h4,{id:"what-the-fragment-shader-does",children:(0,t.jsx)(n.strong,{children:"What the Fragment Shader Does:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coloring and Texturing"}),": It computes the color of a pixel based on inputs from the vertex shader, like interpolated color, lighting, and texture data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lighting"}),": Per-pixel lighting can be calculated for more accurate and realistic rendering (e.g., diffuse and specular lighting)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Outputs pixel color"}),": The fragment shader outputs the final color that will be drawn on the screen at a specific pixel location."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-workflow-1",children:"Example Workflow:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Interpolated data from the vertex shader (like position, color, and texture coordinates) is passed to the fragment shader for each pixel."}),"\n",(0,t.jsx)(n.li,{children:"The fragment shader calculates the color of the pixel using various techniques, including texturing, lighting, or procedural shading."}),"\n",(0,t.jsx)(n.li,{children:"The fragment shader outputs the final color for each pixel on the screen."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-glsl-fragment-shader",children:"Example GLSL Fragment Shader:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-glsl",children:"#version 330 core\nin vec3 vColor; // Input from vertex shader\n\nout vec4 FragColor; // Output final color\n\nvoid main()\n{\n    // Set the fragment's color\n    FragColor = vec4(vColor, 1.0); // Set final pixel color\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Input"}),": Data like interpolated color and texture coordinates from the vertex shader."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Output"}),": Final color of each pixel."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"how-vertex-and-fragment-shaders-work-together",children:(0,t.jsx)(n.strong,{children:"How Vertex and Fragment Shaders Work Together"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Model Definition"}),": A 3D model is defined with a set of vertices (points in space)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Vertex Shader Stage"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The vertex shader runs once for each vertex."}),"\n",(0,t.jsx)(n.li,{children:"It processes the vertex\u2019s position and applies transformations, such as model, view, and projection transformations."}),"\n",(0,t.jsxs)(n.li,{children:["It sends transformed vertex positions and other attributes (like color or texture coordinates) to the ",(0,t.jsx)(n.strong,{children:"rasterizer"})," stage."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Rasterization"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The rasterizer converts the transformed 3D triangles into a set of 2D fragments (potential pixels) on the screen."}),"\n",(0,t.jsx)(n.li,{children:"It interpolates the attributes passed from the vertex shader (e.g., color and texture coordinates) across each triangle."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Fragment Shader Stage"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The fragment shader runs for each fragment generated by the rasterizer."}),"\n",(0,t.jsx)(n.li,{children:"It computes the final color of the pixel, possibly using interpolated data (like color, lighting, or texture data)."}),"\n",(0,t.jsx)(n.li,{children:"This color is then written to the framebuffer (the final image)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"visual-representation",children:[(0,t.jsx)(n.strong,{children:"Visual Representation"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Vertex Shader"}),": Handles ",(0,t.jsx)(n.strong,{children:"per-vertex"})," calculations like position and basic lighting."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rasterizer"}),": Converts the triangle formed by the vertices into pixels."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fragment Shader"}),": Handles ",(0,t.jsx)(n.strong,{children:"per-pixel"})," calculations like coloring and detailed lighting."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"key-differences",children:(0,t.jsx)(n.strong,{children:"Key Differences:"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Vertex Shader"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Fragment Shader"})})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:["Processes ",(0,t.jsx)(n.strong,{children:"vertices"})," (points in 3D space)."]}),(0,t.jsxs)(n.td,{children:["Processes ",(0,t.jsx)(n.strong,{children:"fragments"})," (potential pixels)."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Handles transformations, like position and lighting."}),(0,t.jsx)(n.td,{children:"Handles coloring, texturing, and pixel-specific effects."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:["Runs ",(0,t.jsx)(n.strong,{children:"once per vertex"}),"."]}),(0,t.jsxs)(n.td,{children:["Runs ",(0,t.jsx)(n.strong,{children:"once per pixel/fragment"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Outputs vertex position and attributes."}),(0,t.jsx)(n.td,{children:"Outputs final pixel color."})]})]})]}),"\n",(0,t.jsxs)(n.h3,{id:"example-use-cases",children:[(0,t.jsx)(n.strong,{children:"Example Use Cases"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Vertex Shader"}),": Used to transform a 3D model's vertices into screen space for rendering."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fragment Shader"}),": Used to apply lighting, shading, and texturing to determine the color of each pixel."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"summary",children:"Summary:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Vertex Shaders"}),": Focus on manipulating vertex positions and attributes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fragment Shaders"}),": Focus on determining the final pixel color by applying textures, lighting, or shading techniques."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These shaders work in tandem to render 3D scenes efficiently on the GPU."})]})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>o,a:()=>l});var t=r(7294);const s={},i=t.createContext(s);function l(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);